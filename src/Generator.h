#pragma once
/// @copyright {2024, Russell J. Fleming. All rights reserved.}
///
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files (the "Software"), to deal
/// in the Software without restriction, including without limitation the rights
/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
/// copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
#include    <coroutine>
#include    <optional>
#include    <iterator>

namespace pentifica::tbox {
/// @brief  Defines a generic iterator
/// @tparam T   Data type generated
template<typename T>
class Generator {
public:
    /// @brief  Encapsulate the value generated by the generator.
    struct promise_type {
        /// @brief  The last generated value
        /// @tparam The type of the generated value
        T current_value_{};

        Generator get_return_object() {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }

        std::suspend_always yield_value(T value) {
            current_value_ = value;
            return {};
        }
        std::suspend_always yield_value(T&& value) {
            current_value_ = std::move(value);
            return {};
        }
        /// @brief  Called when coroutine completes
        void return_void() {}
        void unhandled_exception() { std::terminate(); }
    };

    using handle_type = std::coroutine_handle<promise_type>;
    /// @brief  Defines an iterator for the generator
    class iterator {
    public:
        using category = std::forward_iterator_tag;
        using value_type = T;

        /// @brief Prepares an iterator for the generator
        /// @param handle 
        explicit iterator(handle_type handle) : handle_(handle) {}
        /// @brief Move the reference to the next generated value
        void operator++() { handle_.resume(); }
        /// @brief Returns the current generated value
        /// @return 
        value_type operator*() const { return handle_.promise().current_value_; }
        /// @brief  Compares an iterator with the end sentinel
        /// @param  
        /// @return 
        bool operator==(std::default_sentinel_t) const {
            return !handle_ || handle_.done();
        }
        /// @brief Compares iterators
        /// @param it 
        /// @return 
        bool operator==(iterator const& it) {
           return it.handle_ == handle_; 
        }

    private:
        handle_type handle_;
    };
    /// @brief  Prepares a generic generator
    /// @param  handle  Handle to the underlying coroutine
    explicit Generator(handle_type handle) : handle_(handle) {}
    /// @brief  Release resources assigned to the generator
    ~Generator() { if(handle_) handle_.destroy(); }
    /// @brief Remove copy ctor to simplify the interface and internal logic
    /// @param  
    Generator(Generator const&) = delete;
    /// @brief Remove assign operator to simplify the interface and internal logic
    /// @param  
    /// @return 
    Generator& operator=(Generator const&) = delete;
    /// @brief  Return the next generated value, if available
    /// @return The next generated value. If no value available, std::nullopt is returned
    std::optional<T> next() {
        if(handle_) {
            handle_.resume();
            if(!handle_.done()) {
                return handle_.promise().current_value_;
            }
        }

        return std::nullopt;
    }
    /// @brief Returns an iterator referencing the first generated value.
    /// @return An iterator referencing the first generated value
    iterator begin() {
        if(handle_) {
            handle_.resume();
        }
        return iterator(handle_);
    }
    /// @brief  Returns a sentinel indicating the end of a generated sequence
    /// @return 
    std::default_sentinel_t end() {
        return {};
    }

private:
    /// @brief  A handle to the underlying coroutine
    handle_type handle_;
};
}